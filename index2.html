<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script src="three.min.js"></script>
    <script src="OrbitControls.js"></script>
    <script src="UndoManager.js"></script>
  </head>
  <body>
    <input
      type="text"
      id="description"
      onkeyup="updateText();"
      maxlength="15"
      style="
        position: absolute;
        top: 50px;
        left: 50px;
        z-index: 100;
        border-radius: 0px solid;
        border-color: black;
      "
    />
    <input
      type="checkbox"
      id="showPlane"
      style="
        position: absolute;
        top: 100px;
        left: 50px;
        z-index: 100;
        border-radius: 0px solid;
        border-color: black;
      "
    />
    <div
      style="position: absolute; top: 50px; right: 50px; display: none"
      id="updateDIV"
    >
      <input
        type="button"
        value="Delete"
        style="z-index: 100; border-radius: 0px solid; border-color: black"
        id="updateDelete"
        onclick="deleteSphere();"
      /><input
        type="text"
        id="updateSelection"
        onkeyup="updateSelection();"
        maxlength="15"
        style="z-index: 100; border-radius: 0px solid; border-color: black"
      />
    </div>
    <script>
      window.onload = function () {
        document.getElementById("description").focus();
      };
      let texts = [];
      var curves = [];
      let tubes = [];
      let descriptions = [];
      
      var keyCode17Disabled = false;
      var plane2 = null;
      var previousDescriptionCheck = '';

      var prevNewRadius = 0;

      let hullsVisible = true;
      let hullSpheres = [];
      let hullParentSpheres = [];
      
      let selectedSphere = null;

      //let tubeGeometries = [];
      let updatingTextObject = null;
      let cameraPos = new THREE.Vector3();
      var font;
      var manager = new THREE.LoadingManager();
      var loader = new THREE.FontLoader(manager);
      var movingHull = null;
      var changedTexts = [];
      var charactersData = [];
      var prevNewRadiuses = [];
      var currentUUID;

      var originalRadius = 0.2;
      
      function updateUI(state) {
        console.log(state.type);
         if (state.type == "resize") 
        {
          let resizedObject = state.id;
          resizedObject.scale.x = state.originalRadius;
          resizedObject.scale.y = state.originalRadius;
          resizedObject.scale.z = state.originalRadius;
          changeSpheres(resizedObject, state.originalRadius);

       
          /*let parentRadiuses = state.childAndParentRadiuses;

          for (var i = 0; i < state.childAndParentRadiuses.length; i++) {
            let sphere = hullParentSpheres.find(function (sphere) {
            return (
              sphere.uuid == hullParentSpheres[i].uuid
            );
          });

          if (sphere) {
            console.log("FOUND");
            sphere.scale.x = state.childAndParentRadiuses[i].scale;
            sphere.scale.y = state.childAndParentRadiuses[i].scale;
            sphere.scale.z = state.childAndParentRadiuses[i].scale;
            sphere.belongingHull.scale.x = state.childAndParentRadiuses[i].hullRadius;
            sphere.belongingHull.scale.y = state.childAndParentRadiuses[i].hullRadius;
            sphere.belongingHull.scale.z = state.childAndParentRadiuses[i].hullRadius;
          }

          }*/

        } else
        if (state.type == "add") 
        {
  
          for (var i = 0; i < state.addedIDs.length; i++) {
            let sphere = hullParentSpheres.find(function (sphere) {
              return (
                sphere.uuid == state.addedIDs[i]
              );
            });
            if (sphere) {
              console.log("REMOVING SPHERE");
              scene.remove(sphere);
            }
            let hull = hullSpheres.find(function (hull) {
              console.log(hull);
              console.log(state.addedIDs[i]);
              return (
                hull.uuid == state.addedIDs[i]
              );
            });
            if (hull) {
              console.log("REMOVING HULL");

              let hullIndex  = hullSpheres.findIndex(function (myHull) {
              return (
                myHull.uuid == hull.uuid
              );
            });

            if (hullIndex!=-1) {
              deleteGlobalSplice(hullIndex);
            }

            removeFromHullSphereIndex(state.addedIDs[i]);

              scene.remove(hull);
            }
            let tube  = tubes.find(function (tube) {
              return (
                tube.uuid == state.addedIDs[i]
              );
            });
            if (tube) {
              console.log("REMOVING TUBE");
             

              let tubeIndex  = tubes.findIndex(function (tube) {
              return (
                tube.uuid == state.addedIDs[i]
              );
            });

            if (tubeIndex!=-1) {
              console.log(tubeIndex);
              console.log(tubes[tubeIndex]);
            if ( tubes[tubeIndex].charactersMeshes ) {
              for (var z = 0; z < tubes[tubeIndex].charactersMeshes.length; z++) {
              scene.remove(tubes[tubeIndex].charactersMeshes[z]);
              }
            }
              deleteGlobalSplice(tubeIndex);
              scene.remove(tube);
          }

            }
            console.log("ADD END");

            
        }

        } else
        if (state.type == "delete") 
        {
          for (var i = 0; i < state.objects.length; i++) {
          
            for (var z = 0; z < state.objects[i].deletedMeshes.length; z++) {
            scene.add(state.objects[i].deletedMeshes[z]);
            }
            addGlobalSplice(i, state);

          }
        } else if (state.type == "changeText") 
        {

          for (let i = 0; i < state.id.charactersMeshes.length; i++) {
            scene.remove(state.id.charactersMeshes[i]);
          }

          descriptions[state.id.index] = state.text;
          previousCheckIfTubeIsOnRightOrLeft[state.id.index] = null;

        }
      }
/*
function addParentRadiuses(resizedObject, childAndParentRadiuses) {
      childAndParentRadiuses.push({
                  uuid : resizedObject.uuid,
                  scale : getScaledRadius(resizedObject),
                  position: resizedObject.position.clone(),
                  hullRadius : getScaledRadius(resizedObject.belongingHull)
                });
      if ( (resizedObject.parentSphere) ) {
            childAndParentRadiuses = addParentRadiuses(resizedObject.parentHull.parentSphere, childAndParentRadiuses);
            }
            return childAndParentRadiuses;
      }
*/

      const removeFromHullSphereIndex = (id) => {

        let hullIndex  = hullSpheres.findIndex(function (hull) {
              return (
                hull.uuid == id
              );
            });

            if (hullIndex!=-1) {
              hullSpheres.splice(hullIndex);
              console.log("HULLSPHERES");
              console.log(hullSpheres);
            }

      };

      const deleteGlobalSplice = (i) => {
            tubes.splice(i, 1);
            changedTexts.splice(i, 1);
            descriptions.splice(i, 1);
            curves.splice(i, 1);
            texts.splice(i, 1);
            previousCheckIfTubeIsOnRightOrLeft.splice(i, 1);
      }

      const addGlobalSplice = (i, state) => {
        
        tubes.push(state.objects[i].tube);
        changedTexts.push(state.objects[i].changedText);
        descriptions.push(state.objects[i].description);
        curves.push(state.objects[i].curve);
        texts.push(state.objects[i].text);
        previousCheckIfTubeIsOnRightOrLeft.push(state.objects[i].previousCheckIfTubeIsOnRightOrLeft);

      }

      // Example of how to initialize and use the UndoManager class
      const undoManager = new UndoManager(updateUI);

      loader.load("font.json", function (response) {
        font = response;
      });
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 0, 5);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      var textOrientation = new THREE.Object3D();
      scene.add(textOrientation);
      let previousCheckIfTubeIsOnRightOrLeft = [];
      
      // Set up orbit controls
      let controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.minPolarAngle = Math.PI / 4; // 45 degrees
      controls.maxPolarAngle = (3 * Math.PI) / 4; // 135 degrees
      let resizedObject;

      // Create sphere
      const sphereRadius = 1;
      const sphereGeometry = new THREE.SphereGeometry(sphereRadius, 32, 32);
      const sphereMaterial = new THREE.MeshBasicMaterial({
        color: 0xaaaaff,
        transparent: true,
        opacity: 0.5,
      });
      const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);

      const addHullToSphere = (sphere) => {
        let hullRadius;
        if (sphere.parentHull == null) {
          hullRadius = getScaledRadius(sphere) * 2; // Hull radius is twice the size of the sphere radius
        } else {
          hullRadius = getScaledRadius(sphere) * 4;
        }
        const hullGeometry = new THREE.SphereGeometry(1, 32, 32);
        const hullMaterial = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.5,
        });
        const hull = new THREE.Mesh(hullGeometry, hullMaterial);

        hull.scale.x = hullRadius;
        hull.scale.y = hullRadius;
        hull.scale.z = hullRadius;

        hull.position.copy(sphere.position);
        hull.parentSphere = sphere;
        sphere.belongingHull = hull;
        hullSpheres.push(hull);
        scene.add(hull);
        return hull;
      };

      const MIN_RADIUS = 0.5; // Minimum allowed radius of the sphere
      scene.add(sphere);

      let isResizing = false;
      let recursiveResizing = false;
      let startingMousePosition = { x: 0, y: 0 };

      window.addEventListener("mousedown", (event) => {
        const mouse = new THREE.Vector2();
        mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
        mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouse, camera);

        // Calculate the intersection between the mouse position and the objects in the scene
        const intersects = raycaster.intersectObjects(scene.children);

        if (intersects.length > 0) {
          const intersection = intersects[0];
          const object = intersection.object;
          if (object.visible == false) return;

          if (
            object instanceof THREE.Mesh &&
            object.material.color.getHex() === 0xaaaaff
          ) {
            if (event.shiftKey) {
              cameraPos.copy(controls.object.position);
              controls.enabled = false;

              isResizing = true;
              charactersData = [];
              resizedObject = object;
              startingMousePosition = { x: event.clientX, y: event.clientY };
            }
          } else if (
            object instanceof THREE.Mesh &&
            object.material.color.getHex() === 0xffffff
          ) {
            if (event.altKey) {
              controls.enabled = false;
              movingHull = object;
            } else if (event.shiftKey) {
              controls.enabled = false;
              resizedObject = object;
              originalRadius = getScaledRadius(object);
             
              currentUUID = object.uuid;
             
              /*let childAndParentRadiuses = addParentRadiuses(resizedObject.parentSphere, []); */

              undoManager.resizeItem(object, originalRadius,  null); // childAndParentRadiuses
               


              if (!prevNewRadiuses[object.uuid]) {
                prevNewRadiuses[object.uuid] = originalRadius;
                prevNewRadius = originalRadius;
              } else {
                prevNewRadius = prevNewRadiuses[object.uuid];
              }
                startingMousePosition = { x: event.clientX, y: event.clientY };
              recursiveResizing = true;
            }
          }
        }
      });

      window.addEventListener("pointerup", () => {
        movingHull = null;
        if (isResizing) {
          isResizing = false;
        } else if (recursiveResizing) {
          recursiveResizing = false;
          delete prevNewRadiuses[currentUUID];
        }
        controls.enabled = true;
        event.preventDefault();
      });


      window.addEventListener("mousemove", (event) => {
        event.preventDefault();
        if (movingHull) {
          moveHull(movingHull);
          return;
        }

        if (!isResizing && !recursiveResizing) {
          return;
        }

        const currentMousePosition = { x: event.clientX, y: event.clientY };
        const mouseMovement = {
          x: currentMousePosition.x - startingMousePosition.x,
          y: currentMousePosition.y - startingMousePosition.y,
        };

        // calculate new radius based on the original radius
        let newRadius =
          originalRadius + mouseMovement.y * 0.01 + mouseMovement.x * 0.01;

        let isHullVisible = false;
        let maxChildSphereRadius;
        let increasing = newRadius > prevNewRadius ? true : false;

        if (isResizing) {
          if (!resizedObject.parentHull) return;
          if (
            newRadius >
            resizedObject.parentHull.geometry.parameters.radius / 2
          )
          return;
        } else if (recursiveResizing) {
          //if (increasing) {
          maxChildSphereRadius = 0;
          //} else {
          //  maxChildSphereRadius = 0;
          //}
          if (resizedObject.spheres) {
            for (let x = 0; x < resizedObject.spheres.length; x++) {
              if (resizedObject.spheres[x].belongingHull) {
                if (
                  getScaledRadius(resizedObject.spheres[x].belongingHull) >
                  maxChildSphereRadius
                ) {
                  maxChildSphereRadius = getScaledRadius(
                    resizedObject.spheres[x].belongingHull
                  );
                }

           
              }
            }
          }
        }

        for (var i = 0; i < changedTexts.length; i++) {
          changedTexts[i] = true;
        }

        if (recursiveResizing) {
          if (!increasing) {
            if (newRadius * 2 <= maxChildSphereRadius) {
              recursiveResizing = false;
              return;
            }

              if (newRadius  < maxChildSphereRadius) {
                recursiveResizing = false;
                resizedObject.scale.x = newRadius;
                resizedObject.scale.y = newRadius;
                resizedObject.scale.z = newRadius;
                return;
              }
              if (newRadius / 2 < getScaledRadius(resizedObject.parentSphere)) {
                recursiveResizing = false;
                return;
              }


          } else {

            if (resizedObject.parentSphere.parentHull) {
              if (getScaledRadius(resizedObject) > resizedObject.parentSphere.parentHull) {
                recursiveResizing = false;
                lastRadius = newRadius;
                return;
              }
            } else {
              console.log(getScaledRadius(resizedObject) + ">2");
            }
          }

          prevNewRadius = newRadius;
          prevNewRadiuses[currentUUID] = newRadius;
          resizedObject.scale.x = newRadius;
          resizedObject.scale.y = newRadius;
          resizedObject.scale.z = newRadius;
        } else {
          prevNewRadius = newRadius;
          prevNewRadiuses[currentUUID] = newRadius;
          resizedObject.scale.x = newRadius;
          resizedObject.scale.y = newRadius;
          resizedObject.scale.z = newRadius;
        }

        if (
          resizedObject.position.x == 0 &&
          resizedObject.position.y == 0 &&
          resizedObject.position.z == 0
        ) {
          changeSpheres(resizedObject, newRadius);
        } else {
          changeSpheres(resizedObject, newRadius);
        }

        if (isResizing) {
          tubeGeometry = new THREE.CylinderGeometry(
            newRadius / 4,
            getScaledRadius(resizedObject.tube.sphere1Mesh) / 4,
            resizedObject.tube.curve.getLength(),
            32
          );

          var tubeMaterial = new THREE.MeshBasicMaterial({
            color: 0xff0000,
            transparent: false,
          });
          let originalDescription = resizedObject.tube.description;
          let originalCharactersMeshes = resizedObject.tube.charactersMeshes;
          scene.remove(resizedObject.tube);
          var tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
          tube.description = originalDescription;
          tube.charactersMeshes = originalCharactersMeshes;
          tube.sphere1Mesh = resizedObject.tube.sphere1Mesh;
          tube.sphere2Mesh = resizedObject.tube.sphere2Mesh;

          // Position and rotate the cylinder to match the curve
          var quaternion = new THREE.Quaternion();
          quaternion.setFromUnitVectors(
            new THREE.Vector3(0, 1, 0),
            new THREE.Vector3()
              .subVectors(
                resizedObject.tube.sphere2Mesh.position,
                resizedObject.tube.sphere1Mesh.position
              )
              .normalize()
          );
          var distance = resizedObject.tube.sphere1Mesh.position.distanceTo(
            resizedObject.tube.sphere2Mesh.position
          );
          tubeGeometry.parameters.height = distance; // update the height of the cylinder
          tubeGeometry.translate(0, distance / 2, 0); //translate cylinder along the y-axis by distance/2

          var matrix = new THREE.Matrix4();
          matrix.makeRotationFromQuaternion(quaternion);
          matrix.setPosition(resizedObject.tube.sphere1Mesh.position);
          tube.applyMatrix4(matrix);

          tube.sphere1Mesh = resizedObject.tube.sphere1Mesh;
          tube.sphere2Mesh = resizedObject.tube.sphere2Mesh;
          tube.curve = resizedObject.tube.curve;
          resizedObject.tube = tube;
          resizedObject.tubeGeometry = tubeGeometry;

          scene.add(tube);
        } else if (recursiveResizing && increasing) {
          let hull = resizedObject.parentSphere.parentHull;

          while (hull) {
            if (getScaledRadius(hull) < getScaledRadius(resizedObject) * 2) {
              hull.scale.x = resizedObject.scale.x;
              hull.scale.y = resizedObject.scale.y;
              hull.scale.z = resizedObject.scale.z;
            }
            changeSpheres(hull, getScaledRadius(hull));

            if (hull.parentSphere && hull.parentSphere.parentHull) {
              hull = hull.parentSphere.parentHull;
            } else {
              hull = null;
            }
          }
          if (checkTooLarge(resizedObject)) return;
        }
      });

      function getTubeRadius(
        outerSphereRadius,
        innerSphereRadius,
        transparentSphereRadius
      ) {
        return (
          (getScouterSphereRadius - innerSphereRadius) / transparentSphereRadius
        );
      }

      function changeSpheres(bigSphere, newRadius) {
        if (!bigSphere.spheres) return;
        for (let i = 0; i < bigSphere.spheres.length; i++) {
          let smallSphere = bigSphere.spheres[i].clone();

          // Calculate the angles between the center of the big sphere and the small sphere
          var dx = smallSphere.position.x - bigSphere.position.x;
          var dy = smallSphere.position.y - bigSphere.position.y;
          var dz = smallSphere.position.z - bigSphere.position.z;
          var distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
          var phi = Math.atan2(dy, dx);
          var theta = Math.acos(dz / distance);

          // Set the new position of the small sphere according to the new radius
          bigSphere.spheres[i].position.set(
            bigSphere.position.x + newRadius * Math.sin(theta) * Math.cos(phi),
            bigSphere.position.y + newRadius * Math.sin(theta) * Math.sin(phi),
            bigSphere.position.z + newRadius * Math.cos(theta)
          );

          let originalDescription = bigSphere.spheres[i].tube.description;
          let originalCharactersMeshes =
            bigSphere.spheres[i].tube.charactersMeshes;
          scene.remove(bigSphere.spheres[i].tube);
          let oldID =bigSphere.spheres[i].tube.uuid; 
          let start = bigSphere.position;
          let end = bigSphere.spheres[i].position;
          let curve = new THREE.LineCurve3(start, end);

          tubeGeometry = new THREE.CylinderGeometry(
            getScaledRadius(smallSphere) / 4,
            getScaledRadius(bigSphere.parentSphere) / 4,
            curve.getLength(),
            32
          );

          var tubeMaterial = new THREE.MeshBasicMaterial({
            color: 0xff0000,
            transparent: false,
          });
          var tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
          tube.description = originalDescription;
          tube.charactersMeshes = originalCharactersMeshes;
          tube.sphere1Mesh = bigSphere.spheres[i].tube.sphere1Mesh;
          tube.sphere2Mesh = bigSphere.spheres[i].tube.sphere2Mesh;
          tube.curve = bigSphere.spheres[i].tube.curve;
          var quaternion = new THREE.Quaternion();
          quaternion.setFromUnitVectors(
            new THREE.Vector3(0, 1, 0),
            new THREE.Vector3()
              .subVectors(bigSphere.spheres[i].position, bigSphere.position)
              .normalize()
          );
          var distance = bigSphere.spheres[i].position.distanceTo(
            bigSphere.position
          );
          tubeGeometry.parameters.height = distance; // update the height of the cylinder
          tubeGeometry.translate(0, distance / 2, 0); //translate cylinder along the y-axis by distance/2

          var matrix = new THREE.Matrix4();
          matrix.makeRotationFromQuaternion(quaternion);
          matrix.setPosition(bigSphere.position);
          tube.applyMatrix4(matrix);
          //tube.sphere1Mesh = bigSphere.tube.sphere1Mesh;
          //tube.sphere2Mesh = bigSphere.tube.sphere2Mesh;
          //tube.curve = bigSphere.tube.curve;
          bigSphere.spheres[i].tube = tube;
          bigSphere.spheres[i].tubeGeometry = tubeGeometry;

          scene.add(tube);

          undoManager.replaceUUID(oldID, tube.uuid);
          let tubeIndex = tubes.findIndex((item) => {
              console.log(item.uuid+"=="+tube.uuid);  
              return (item.uuid === oldID);
            });
            console.log("tubeindex:"+tubeIndex);
          if (tubeIndex!=-1) {
            console.log("UPDATING TUBE "+tubeIndex);
            tubes[tubeIndex]=tube;
          }
         

          if (!bigSphere.spheres[i].belongingHull) {
          } else {
            let hullSphere = bigSphere.spheres[i].belongingHull;
            changePos(
              distanceBetweenPositions(
                smallSphere.position,
                bigSphere.spheres[i].position
              ),
              hullSphere,
              bigSphere
            );
          }
        }
      }

      function distanceBetweenPositions(oldPosition, newPosition) {
        var xDiff = newPosition.x - oldPosition.x;
        var yDiff = newPosition.y - oldPosition.y;
        var zDiff = newPosition.z - oldPosition.z;
        return new THREE.Vector3(xDiff, yDiff, zDiff);
      }

      const moveHull = (movingHull) => {
        const mouse = new THREE.Vector2();
        mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
        mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouse, camera);

        // Calculate the intersection between the mouse position and the objects in the scene
        const intersects = raycaster.intersectObjects(scene.children);

        if (intersects.length > 0) {
          for (var i = 0; i < intersects.length; i++) {
            const intersection = intersects[i];
            const object = intersection.object;
            let originalPos = object.position.clone();
            if (object.uuid == movingHull.parentSphere.parentHull.uuid) {

              let curve = new THREE.LineCurve3(
                movingHull.parentSphere.parentHull.position,
                intersection.point
              );
              let tubeGeometry = new THREE.CylinderGeometry(
                getScaledRadius(movingHull.parentSphere.tube.sphere2Mesh) / 4,
                getScaledRadius(movingHull.parentSphere.tube.sphere1Mesh) / 4,
                curve.getLength(),
                32
              );

              let originalPosition = movingHull.parentSphere.position.clone();
              movingHull.parentSphere.position.copy(intersection.point);
              let originalDescription =
                movingHull.parentSphere.tube.description;
              let originalCharactersMeshes =
                movingHull.parentSphere.tube.charactersMeshes;
              movingHull.position.copy(intersection.point);
             
              var tubeMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: false,
                opacity: 0.5,
              });

              var tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
              tube.description = originalDescription;
              tube.charactersMeshes = originalCharactersMeshes;
             

              // Position and rotate the cylinder to match the curve
              var quaternion = new THREE.Quaternion();
              quaternion.setFromUnitVectors(
                new THREE.Vector3(0, 1, 0),
                new THREE.Vector3()
                  .subVectors(
                    movingHull.parentSphere.tube.sphere2Mesh.position,
                    movingHull.parentSphere.tube.sphere1Mesh.position
                  )
                  .normalize()
              );
              var distance =
                movingHull.parentSphere.tube.sphere1Mesh.position.distanceTo(
                  movingHull.parentSphere.tube.sphere2Mesh.position
                );
              tubeGeometry.parameters.height = distance; // update the height of the cylinder
              tubeGeometry.translate(0, distance / 2, 0); //translate cylinder along the y-axis by distance/2

              var matrix = new THREE.Matrix4();
              matrix.makeRotationFromQuaternion(quaternion);
              matrix.setPosition(
                movingHull.parentSphere.tube.sphere1Mesh.position
              );
              tube.applyMatrix4(matrix);

              tube.sphere1Mesh = movingHull.parentSphere.tube.sphere1Mesh;
              tube.sphere2Mesh = movingHull.parentSphere.tube.sphere2Mesh;
              tube.charactersMeshes = movingHull.parentSphere.tube.charactersMeshes;
              tube.curve = movingHull.parentSphere.tube.curve;
              scene.remove(movingHull.parentSphere.tube);
              movingHull.parentSphere.tube = tube;
              movingHull.parentSphere.tubeGeometry = tubeGeometry;

              scene.add(tube);
              for (var z = 0; z < changedTexts.length; z++) {
                changedTexts[z] = true;
              }
              if (movingHull.spheres) {
                //for (var x = 0; x < movingHull.spheres.length; x++) {

                changePos(
                  distanceBetweenPositions(
                    originalPosition,
                    intersection.point
                  ),
                  movingHull,
                  movingHull
                );
                //}
              }
            }
          }
        }
      };

      function getRandomColor() {
        let colors = [0xff0000, 0x00ff00, 0xaaaaaa, 0x0000ff];
        let color = Math.floor(Math.random() * 4);
        return colors[color];
      }

      function changePos(vector, hullSphere) {
        if (hullSphere) {
          hullSphere.position.add(vector);
          if (hullSphere.tube) {
            hullSphere.tube.position.add(vector);
          }
          if (hullSphere.spheres) {
            let spheres = hullSphere.spheres;
            for (let z = 0; z < hullSphere.spheres.length; z++) {
              hullSphere.spheres[z].position.add(vector);
              if (hullSphere.spheres[z].tube) {
                hullSphere.spheres[z].tube.position.add(vector);
              }
              changePos(vector, hullSphere.spheres[z].belongingHull);
            }
          }
        }
      }

      function updateText() {
        let description = document.getElementById("description").value;
        if (description != "") {
          document.getElementById("description").style.border = "0px solid";
        } else {
          document.getElementById("description").style.border = "3px solid";
          document.getElementById("description").style.borderColor = "red";
        }
      }

      function updateSelection() {
        if (updatingTextObject != null) {

          

          let description = document.getElementById("updateSelection").value;
          

          if (previousDescriptionCheck != description) {
            undoManager.changeItemText(updatingTextObject, description);
            for (let i = 0; i < updatingTextObject.charactersMeshes.length; i++) {
              scene.remove(updatingTextObject.charactersMeshes[i]);
            }

            descriptions[updatingTextObject.index] = description;
            previousCheckIfTubeIsOnRightOrLeft[updatingTextObject.index] = null;
            previousDescriptionCheck = description;
          }
        }
      }

      function addSphere(hull) {
        // Calculate the position of the mouse click on the hull
        const mouse = new THREE.Vector2();
        mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
        mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObject(hull);
        if (intersects.length > 0) {
          const intersection = intersects[0];
          const sphereRadius = getScaledRadius(hull) / 8; // New sphere radius is half the size of the hull
          const sphereGeometry = new THREE.SphereGeometry(1, 32, 32);
          const sphereMaterial = new THREE.MeshBasicMaterial({
            color: 0xaaaaff,
            transparent: true,
            opacity: 0.5,
          });
          const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);

          // create line between inner and outer sphere

          sphere.scale.x = sphereRadius;
          sphere.scale.y = sphereRadius;
          sphere.scale.z = sphereRadius;

          sphere.position.copy(intersection.point);
          sphere.parentHull = hull;

          scene.add(sphere);

          let myDirection = new THREE.Vector3()
            .subVectors(sphere.position, hull.position)
            .normalize();

          sphere.tube = addText(
            document.getElementById("description").value,
            sphere.parentHull.parentSphere,
            sphere,
            sphereRadius
          
          );
          //hull.parentSphere.tube = sphere.tube;

          if (!hull.spheres) {
            hull.spheres = [sphere];
          } else {
            hull.spheres.push(sphere);
          }
          hullParentSpheres.push(sphere);
          return sphere;
        }
        return null;
      }

      function addText(description, sphere1, sphere2, sphereRadius) {
        // Create the line curve and tube geometry

        let curve = new THREE.LineCurve3(sphere1.position, sphere2.position);

        //        tubeGeometry = new THREE.TubeGeometry(curve, 20, 0.1, 8, false);
        tubeGeometry = new THREE.CylinderGeometry(
          sphereRadius / 4,
          getScaledRadius(sphere1) / 4,
          curve.getLength(),
          32
        );

        var tubeMaterial = new THREE.MeshBasicMaterial({
          color: 0xff0000,
          transparent: false,
        });
        var tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
        // Position and rotate the cylinder to match the curve
        var quaternion = new THREE.Quaternion();
        quaternion.setFromUnitVectors(
          new THREE.Vector3(0, 1, 0),
          new THREE.Vector3()
            .subVectors(sphere2.position, sphere1.position)
            .normalize()
        );
        var distance = sphere1.position.distanceTo(sphere2.position);
        tubeGeometry.parameters.height = distance; // update the height of the cylinder
        tubeGeometry.translate(0, distance / 2, 0); //translate cylinder along the y-axis by distance/2

        var matrix = new THREE.Matrix4();
        matrix.makeRotationFromQuaternion(quaternion);
        matrix.setPosition(sphere1.position);
        tube.applyMatrix4(matrix);

        tube.sphere1Mesh = sphere1;
        tube.sphere2Mesh = sphere2;

        scene.add(tube);
        texts.push([]);
        changedTexts.push(false);
        curves.push(curve);
        descriptions.push(description);

        var textOrientation = new THREE.Object3D();

        // Add the text orientation object to the scene
        scene.add(textOrientation);

        tubes.push(tube);

        //tubeGeometries.push(tubeGeometry);
        return tube;
      }
      window.addEventListener(
        "contextmenu",
        function (ev) {
          ev.preventDefault();

          hullSpheres.forEach((sphere) => (sphere.visible = false));

          const mouse = new THREE.Vector2();
          mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
          mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;
          const raycaster = new THREE.Raycaster();
          raycaster.setFromCamera(mouse, camera);

          // Calculate the intersection between the mouse position and the objects in the scene
          const intersects = raycaster.intersectObjects(scene.children);
          updatingTextObject = null;
          if (intersects.length > 0) {
            let max = intersects.length;
            if (intersects.length > 3) max = 3;
            for (var i = 0; i < max; i++) {
              const intersection = intersects[i];
              const object = intersection.object;
              let found = false;
              if (object instanceof THREE.Mesh) {
                if (
                  object.geometry.type == "SphereGeometry" &&
                  object.material.color.getHex() == 0xaaaaff
                ) {
                  console.error(object);
                  if (object.tube) {
                    updatingTextObject = object.tube;
                    document.getElementById("updateDIV").style.display =
                      "inline";
                    document.getElementById("updateSelection").focus();

                    document.getElementById("updateSelection").value =
                      object.tube.description;
                  }
                  found = true;
                  break;
                }
              }
              if (!found) {
                document.getElementById("updateDIV").style.display = "none";
              }
            }
          }
          hullSpheres.forEach((sphere) => (sphere.visible = true));
          return false;
        },
        false
      );

      function deleteSphere() {
        
        deletedItems = deleteSphereSub(updatingTextObject.uuid, []);
        undoManager.deleteItem(updatingTextObject.uuid, deletedItems);
        document.getElementById("updateDIV").style.display = "none";
      }

      function deleteSphereSub(uuid, deletedItems) {
        for (var i = 0; i < tubes.length; i++) {
          let tube = tubes[i];
          if (tube.uuid == uuid) {
            let index = tubes.findIndex((item) => {
                return (item.uuid == tube.uuid);
              });
           
            let deletedMeshes = [];
            let charactersMeshes = texts[i];
            for (let z = 0; z < charactersMeshes.length; z++) {
              scene.remove(charactersMeshes[z]);
              deletedMeshes.push(charactersMeshes[z]);
            }
           
            
            scene.remove(tube.sphere2Mesh);
            deletedMeshes.push(
                tube.sphere2Mesh
              );
            scene.remove(tube);
            deletedMeshes.push(tube);


             
              
            if (tube.sphere2Mesh.belongingHull) {
              if (tube.sphere2Mesh.belongingHull.spheres) {
                for (
                  var z = 0;
                  z < tube.sphere2Mesh.belongingHull.spheres.length;
                  z++
                ) {
                  console.log(
                    "Deleting uuid " +
                      tube.sphere2Mesh.belongingHull.spheres[z].tube.uuid
                  );

                  deletedItems = deleteSphereSub(
                    tube.sphere2Mesh.belongingHull.spheres[z].tube.uuid, deletedItems
                  );
                }
              }
              scene.remove(tube.sphere2Mesh.belongingHull);
              deletedMeshes.push(tube.sphere2Mesh.belongingHull);
             
            }

            deletedItems.push({
                deletedMeshes: deletedMeshes,
                tube : tubes[index],
                changedText : changedTexts[index],
                description: descriptions[index],
                curve: curves[index],
                text: texts[index],
                previousCheckIfTubeIsOnRightOrLeft : previousCheckIfTubeIsOnRightOrLeft[index]
              })

              deleteGlobalSplice(i);


            break;
          }
        }
        return deletedItems;
      }

      window.addEventListener("click", () => {
        const mouse = new THREE.Vector2();
        mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
        mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouse, camera);

        // Calculate the intersection between the mouse position and the objects in the scene
        const intersects = raycaster.intersectObjects(scene.children);
        if (intersects.length > 0) {
          const intersection = intersects[0];
          const object = intersection.object;
          if (
            object instanceof THREE.Mesh &&
            object.material.color.getHex() === 0xaaaaff
          ) {
            let hull = addHullToSphere(object);
            console.log(object);
            if (object.belongingHull.parentSphere.tube) {
              console.log("11111111111");
              undoManager.addItem(hull.uuid, [  hull.uuid ]);
            } else {
              console.log("222222222"+hull.id);
              undoManager.addItem(hull.uuid, [hull.uuid]);
            }
          } else {
            if (document.getElementById("description").value == "") {
              document.getElementById("description").focus();
              document.getElementById("description").style.border = "3px solid";
              document.getElementById("description").style.borderColor = "red";
            } else {
              let sphere = addSphere(object);
              if (sphere != null) {
                console.log(sphere);
                undoManager.addItem(
                  sphere.uuid,
                  [sphere.uuid, sphere.tube.uuid]                
                );
              }
              document.getElementById("description").value = "";
            }
          }
        }

        isHullVisible = true;
      });

      // rotation speed and starting percentage
      var percentage = 0;
      let offset = 0.2;

      
      //animate()
      const animate = () => {
      
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
        var secondAlignerObject = null;
        var counter = 0;
        for (var i = 0; i < texts.length; i++) {
          let charactersMeshes = texts[i];
//          let tubeGeometry = tubeGeometries[i];
          var tube = tubes[i];
          let description = descriptions[i];
          var curve = curves[i];
          let myDirection;

          let opposite = false;

          let currentTubeDirection = checkIfTubeIsOnRightOrLeft(
            //tubeGeometry.parameters.path.getPointAt(0.5)
            curve.getPointAt(0.5)
          );

          myDirection = new THREE.Vector3()
            .subVectors(tube.sphere2Mesh.position, tube.sphere1Mesh.position)
            .normalize();
          startPosition = tube.sphere1Mesh.position
            .clone()
            .add(
              myDirection
                .clone()
                .multiplyScalar(getScaledRadius(tube.sphere1Mesh))
            );
          endPosition = tube.sphere2Mesh.position
            .clone()
            .sub(
              myDirection
                .clone()
                .multiplyScalar(getScaledRadius(tube.sphere2Mesh))
            );

          if (
            previousCheckIfTubeIsOnRightOrLeft[i] == null ||
            previousCheckIfTubeIsOnRightOrLeft[i] != currentTubeDirection ||
            changedTexts[i] == true
          ) {
            changedTexts[i] = false;
            for (let z = 0; z < charactersMeshes.length; z++) {
              scene.remove(charactersMeshes[z]);
            }

            let myText = currentTubeDirection
              ? description
              : reverseString(description);
            charactersMeshes = createCharacterMessages(
              myText,
              curve,
              tube,
              startPosition,
              endPosition
            );
            tube.description = description;
            tube.curve = curve;
            tube.charactersMeshes = charactersMeshes;
            tube.index = i;
            texts[i] = charactersMeshes;
          }

          previousCheckIfTubeIsOnRightOrLeft[i] = currentTubeDirection;
          charactersMeshes.forEach((characterMesh, index) => {
            let points = [];
            var center = curve.getPointAt(0.75);
            let start = curve.getPointAt(0);
            let end = curve.getPointAt(1);

            /*if (document.getElementById("showPlane").checked) {
              if (secondAlignerObject) scene.remove(secondAlignerObject);
            }*/

            plane2 = createPlane(description, scene, start, end);

            let usedRayCaster = null;
            let done = false;
            let data;
            let point;
            let counter = 0;
            let raycastCount;

            while (done == false) {
              raycastCount = 0;

              let divider = 1 / 15;
              if (counter == 1) {
                divider = 1 / 30;
              }
              for (let x = 0; x <= 1; x += divider) {
                let angle = x * Math.PI * 2;

                let scaledSphereRadius = getScaledRadius(tube.sphere1Mesh); 
                point = new THREE.Vector3(
                  center.x +
                    (scaledSphereRadius / 2) *
                      Math.cos(angle),
                  center.y +
                    (scaledSphereRadius / 2) *
                      Math.sin(angle),
                  center.z
                );

                let mode = 0;

                if (usedRayCaster != null) {
                  if (usedRayCaster == false) mode = 1;
                  else mode = 2;
                }

                data = checkPointVisibility(
                  plane2,
                  currentTubeDirection,
                  point,
                  end,
                  start,
                  camera,
                  tube,
                  points,
                  counter,
                  mode
                );

                if (data.point != null) {
                  points.push(data.point);
                }
                if (data.usedRaycaster == true) raycastCount++;
              }
              if (points.length < 3) {
                counter++;
              } else {
                done = true;
              }

              if (data.raycastCount > points.length / 2) usedRayCaster = true;
              else usedRayCaster = false;

              if (counter == 2) done = true;
              // console.error("POINTS:LENGTH:"+points.length);
            }

            //console.error("LEN:"+points.length);
            if (points.length == 0) {
              points.push(characterMesh.position);
            }

            let closestPoint = points[0];
            let closestScreenY = Infinity;
            let closestDistance = camera.position.distanceTo(closestPoint);
            points.forEach((point) => {
              let distance = camera.position.distanceTo(point);
              let screenPos = point.clone().project(camera);
              let weightDistance = 0.4;
              let weightY = 0.6;
              let screenY = screenPos.y;
              if (
                distance * weightDistance + screenY * (1 - weightY) <
                closestDistance * weightDistance +
                  closestScreenY * (1 - weightY)
              ) {
                closestPoint = point;
                closestDistance = distance;
                closestScreenY = screenY;
              }
            });

            let reference = closestPoint;

            let nextPoint = getNextPoint(reference, startPosition, endPosition);

            let referenceToClosest = new THREE.Vector3().subVectors(
              reference,
              nextPoint
            );
            let distance3 = referenceToClosest.length();
            let direction3 = referenceToClosest.normalize();
            let startPosition2 = new THREE.Vector3().addVectors(
              startPosition,
              direction3.multiplyScalar(distance3)
            );

            let referenceToClosest2 = new THREE.Vector3().subVectors(
              reference,
              nextPoint
            );
            let distance4 = referenceToClosest2.length();
            let direction4 = referenceToClosest2.normalize();
            let endPosition2 = new THREE.Vector3().addVectors(
              endPosition,
              direction4.multiplyScalar(distance4)
            );

            let distance =
              startPosition2.distanceTo(endPosition2) /
              (charactersMeshes.length - 1);

            let direction = new THREE.Vector3()
              .subVectors(endPosition, startPosition)
              .normalize();

            let width =
              characterMesh.geometry.boundingBox.max.x -
              characterMesh.geometry.boundingBox.min.x;
            let pos;
            if (!currentTubeDirection) {
              pos = startPosition2
                .clone()
                .add(
                  direction.clone().multiplyScalar(index * distance + width / 2)
                );
            } else {
              pos = startPosition2
                .clone()
                .add(
                  direction.clone().multiplyScalar(index * distance - width / 2)
                );
            }
            characterMesh.position.set(pos.x, pos.y, pos.z);

            characterMesh.lookAt(camera.position);

            if (!scene.children.includes(characterMesh)) {
              scene.add(characterMesh);
            }

            //let line = new THREE.Line3(startPosition, endPosition);
          });
        }
      };

      
      animate();

      function checkTooLarge(resizedObject) {
        if (resizedObject.parentSphere.parentHull) {
          let parentRadius =
            getScaledRadius(resizedObject.parentSphere.parentHull) / 2;
          if (getScaledRadius(resizedObject) * 2 > parentRadius) {
            return true;
          }
        } else {
          console.log("ERROR NO RADIUS");
        }
        return false;
      }

      function getNextPoint(reference, startPosition, endPositon) {
        let tubeDirection = new THREE.Vector3()
          .subVectors(endPosition, startPosition)
          .normalize();
        let nextDirection = new THREE.Vector3().subVectors(
          reference,
          startPosition
        );
        let dotProduct = nextDirection.dot(tubeDirection);
        let closestPoint = new THREE.Vector3().addVectors(
          startPosition,
          tubeDirection.multiplyScalar(dotProduct)
        );

        return closestPoint;
      }

      function getScaledRadius(mesh) {
        /*let scale = mesh.scale;
        let unscaledRadius = mesh.geometry.boundingSphere.radius;*/
        let scaledRadius = Math.max(mesh.scale.x, mesh.scale.y, mesh.scale.z); // * unscaledRadius;
        return scaledRadius;
      }

      function reverseString(str) {
        var splitString = str.split("");
        var reverseArray = splitString.reverse();
        var joinArray = reverseArray.join("");
        return joinArray;
      }

      function checkPointVisibility(
        plane2,
        currentTubeDirection,
        point,
        tubeEnd,
        tubeStart,
        camera,
        tube,
        points,
        counter
      ) {
        var normal = plane2.normal;
        var origin = new THREE.Vector3(0, 0, 0);
        var direction = new THREE.Vector3().subVectors(point, origin);

        var dot2 = normal.dot(direction);

        if (!currentTubeDirection) {
          if (dot2 <= 0) {
            // counter = 1;
          } else {
            return { point, usedRaycaster: false };
          }
        } else {
          if (dot2 > 0) {
            // counter = 1;
          } else {
            return { point, usedRaycaster: false };
          }
        }

        let raycaster1 = new THREE.Raycaster();
        let raycaster2 = new THREE.Raycaster();
        let raycaster3 = new THREE.Raycaster();
        let raycaster4 = new THREE.Raycaster();

        let cameraToPoint = new THREE.Vector3()
          .subVectors(point, camera.position)
          .normalize();
        let cameraToTubeEnd = new THREE.Vector3()
          .subVectors(tubeEnd, camera.position)
          .normalize();
        let pointToTubeEnd = new THREE.Vector3()
          .subVectors(tubeEnd, point)
          .normalize();
        let pointToTubeStart = new THREE.Vector3()
          .subVectors(tubeStart, point)
          .normalize();

        raycaster1.set(point, cameraToPoint);
        raycaster2.set(point, cameraToTubeEnd);
        raycaster3.set(point, pointToTubeEnd);
        raycaster4.set(point, pointToTubeStart);

        let intersects1 = raycaster1.intersectObject(tube);
        let intersects2 = raycaster2.intersectObject(tube);
        let intersects3 = raycaster3.intersectObject(tube);
        let intersects4 = raycaster3.intersectObject(tube);
        if (
          intersects1.length == 0 &&
          intersects2.length == 0 &&
          intersects3.length > 0 &&
          intersects4.length > 0
        ) {
          let intersectionPoint = intersects3[0].point;
          let distance = point.distanceTo(intersectionPoint);
          let intersectionPoint2 = intersects4[0].point;
          let distance2 = point.distanceTo(intersectionPoint2);

          if (currentTubeDirection) {
            if (distance2 < 0.47) {
              return { point, usedRaycaster: true };
            } else if (distance < 0.47) {
              return { point, usedRaycaster: true };
            }
          } else {
            if (distance2 > 0.47) {
              return { point, usedRaycaster: true };
            } else if (distance > 0.47) {
              return { point, usedRaycaster: true };
            }
          }
        }
        return { point: null, usedRaycaster: true };
      }

      function createCharacterMessages(
        text,
        curve,
        tube,
        startPosition,
        endPosition
      ) {
        var characters = text.split("");

        let charactersMeshes = [];

        // Create a text geometry for each character
        characters.forEach(function (character, index) {
          var curvePoint = curve.getPointAt(0 + index / text.length);

          let targetCharacter = charactersData.find(function (characterData) {
            return (
              characterData.character == character &&
              characterData.curvePointX == curvePoint.x &&
              characterData.curvePointY == curvePoint.y &&
              characterData.curvePointZ == curvePoint.z
            );
          });

          if (!targetCharacter) {
            var textGeometry = new THREE.TextGeometry(character, {
              font: font,
              size: 0.1,
              height: 0.05,
            });

            // Create a mesh for each character
            var textMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            var characterMesh = new THREE.Mesh(textGeometry, textMaterial);

            let distance2 = new THREE.Vector3()
              .subVectors(endPosition, startPosition)
              .length();

            let scaling = (distance2 / 0.1) * 0.05;
            characterMesh.scale.set(scaling, scaling, scaling);

            var tangent = curve.getTangent(index / text.length);

            var boundingBox = new THREE.Box3().setFromObject(characterMesh);
            let size = boundingBox.getSize(new THREE.Vector3());

            characterMesh.position.x = curvePoint.x - size.x / 2;
            characterMesh.position.y = curvePoint.y - size.y / 2;
            characterMesh.position.z = curvePoint.z - size.z / 2;

            // Add the tube as a child of the parent object

            charactersMeshes.push(characterMesh);

            charactersData.push({
              character: character,
              curvePointX: curvePoint.x,
              curvePointY: curvePoint.y,
              curvePointZ: curvePoint.z,
              characterMesh: characterMesh,
            });
          } else {
            charactersMeshes.push(targetCharacter.characterMesh);
          }
        });
        return charactersMeshes;
      }

      function checkIfTubeIsOnRightOrLeft(tubeEndPosition) {
        var cameraDirection = new THREE.Vector3()
          .subVectors(camera.position, new THREE.Vector3(0, 0, 0))
          .normalize();
        var tubeDirection = new THREE.Vector3()
          .subVectors(tubeEndPosition, new THREE.Vector3(0, 0, 0))
          .normalize();
        var crossProduct = new THREE.Vector3().crossVectors(
          cameraDirection,
          tubeDirection
        );
        var y = crossProduct.y;
        if (y > 0) {
          return true;
        } else {
          return false;
        }
      }

      function KeyPress(e) {
        var evtobj = window.event ? event : e;
        if (evtobj.keyCode == 27) {
          keyCode17Disabled = !keyCode17Disabled;
        } else
        if ( (evtobj.keyCode == 17) && (keyCode17Disabled == false) ) {
          hullsVisible = !hullsVisible;
          for (var i = 0; i < hullSpheres.length; i++) {
            hullSpheres[i].visible = hullsVisible;
          }
        } else if (evtobj.keyCode == 90 && evtobj.ctrlKey) {
          undoManager.undo(); // undoes the last change text action
        }
      }

      const createPlane = (
        description,
        scene,
        sphere1Position,
        sphere2Position
      ) => {
        var quaternion = new THREE.Quaternion();

        quaternion.setFromUnitVectors(
          new THREE.Vector3(0, 1, 0),
          new THREE.Vector3()
            .subVectors(sphere2Position, sphere1Position)
            .normalize()
        );
        var distance = sphere1Position.distanceTo(sphere2Position);

        secondAlignerObject = new THREE.Object3D();
        let secondPlaneGeometry = new THREE.PlaneGeometry(5, 5);
        let secondPlaneMaterial = new THREE.MeshBasicMaterial({
          color: 0xffff00,
          side: THREE.DoubleSide,
        });

        let secondPlane = new THREE.Mesh(
          secondPlaneGeometry,
          secondPlaneMaterial
        );

        secondPlane.rotateX(Math.PI / 2);
        secondPlane.position.set(0, tubeGeometry.parameters.height / 2, 0);
        //secondAlignerObject.quaternion.copy(quaternion);
        //secondAlignerObject.add(secondPlane);

        /** Third plane **/
        let thirdPlaneGeometry = new THREE.PlaneGeometry(5, 5);
        let thirdPlaneMaterial = new THREE.MeshBasicMaterial({
          color: 0x00ff00,
          side: THREE.DoubleSide,
        });

        let thirdPlaneMesh = new THREE.Mesh(
          thirdPlaneGeometry,
          thirdPlaneMaterial
        );

        thirdPlaneMesh.applyMatrix4(
          new THREE.Matrix4().makeRotationY(Math.PI / 2)
        );
        thirdPlaneMesh.position.copy(secondPlane.position);
        //secondAlignerObject.add(thirdPlaneMesh);
        //secondAlignerObject.position.copy(sphere1Position);

        /*if (document.getElementById("showPlane").checked) {
          if (description == "123" || description == "asd") {
            scene.add(secondAlignerObject);
          }
        }*/

        let thirdPlane = new THREE.Plane(
          thirdPlaneGeometry.vertices[0],
          thirdPlaneGeometry.vertices[1],
          thirdPlaneGeometry.vertices[2]
        );

        return thirdPlane;
      };

      document.onkeydown = KeyPress;
    </script>
  </body>
</html>
